<html>
  <head>
    <title>QL</title>
    <meta charset="UTF-8" />
    <script src="md5.js"></script>
    <script src="download.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js"></script>
    <script>
      /**
       * 环境
       */
      class Env {
        constructor(ctx, width, height, size) {
          this.ctx = ctx;
          this.width = width;
          this.height = height;
          this.size = size;
          //单个大小
          this.w = width / size;
          this.h = height / size;
        }

        getRandomXY() {
          return [(Math.random() * this.w) | 0, (Math.random() * this.h) | 0];
        }

        XY2Index(x, y) {
          return y * this.w + x;
        }

        Index2XY(index) {
          return [index % this.w, (index / this.w) | 0];
        }

        newFood() {
          const list = [];
          this.consume = 0;
          for (let i = 0; i < this.w; i++) {
            for (let j = 0; j < this.h; j++) {
              if (this.data[i][j] === -1) {
                list.push([i, j]);
              }
            }
          }
          if (list.length === 0) {
            this.food = null;
            return false;
          }
          const [x, y] = list[Math.floor(Math.random() * list.length)];
          this.data[x][y] = -3;
          this.food = [x, y];
          return true;
        }

        newSnake() {
          // clear old snake
          const [x, y] = this.getRandomXY();
          this.data[x][y] = this.XY2Index(x, y);
          this.snake_start = [x, y];
          this.snake_end = [x, y];
          this.snake_len = 1;
        }

        get colors() {
          return {
            " ": "white",
            "#": "black",
            o: "green",
            "*": "gray",
            "@": "blue"
          };
        }

        get renderData() {
          const data = this.data.map((col) =>
            col.map((data) => {
              switch (data) {
                case -1:
                  return " ";
                case -2:
                  return "#";
                case -3:
                  return "o";
                default:
                  return "*";
              }
            })
          );
          const [x, y] = this.snake_start;
          data[x][y] = "@";
          return data;
        }

        // get food(){
        //   for(let i = 0; i < this.w; i++)
        //     for(let j = 0; j < this.h; j++)
        //       if(this.isFood(i, j))
        //         return [i, j];
        // }

        /**
         * 返回环境的hash值
         * @type {string}
         */
        get observation() {
          const [snakeX, snakeY] = this.snake_start;
          const [endX, endY] = this.snake_end;
          const foodPos = this.food;
          if (!foodPos) return "over";
          const [foodX, foodY] = foodPos;

          const allAround = [
            this.getSpaces(snakeX, snakeY, (x, y) => [x, y - 1]),
            this.getSpaces(snakeX, snakeY, (x, y) => [x, y + 1]),
            this.getSpaces(snakeX, snakeY, (x, y) => [x - 1, y]),
            this.getSpaces(snakeX, snakeY, (x, y) => [x + 1, y]),
            this.isWall(snakeX - 1, snakeY - 1) | 0,
            this.isWall(snakeX + 1, snakeY - 1) | 0,
            this.isWall(snakeX + 1, snakeY + 1) | 0,
            this.isWall(snakeX - 1, snakeY + 1) | 0
          ];
          //直接把环境的描述转为string后求hash作为观察值
          //观察值 表示食物到头部距离和头部到尾部距离 以及头部周围格子的状态
          const ob = [
            [foodX - snakeX, foodY - snakeY],
            [endX - snakeX, endY - snakeY],
            allAround
          ];
          //观察向量
          const obr = allAround.concat(ob[0], ob[1]);
          // console.log(obr);
          // return b64_md5(JSON.stringify(ob));

          return JSON.stringify(obr);
        }

        getSpaces(x, y, next) {
          let i = 0;
          [x, y] = next(x, y);
          for (; !this.isWall(x, y); i++) {
            [x, y] = next(x, y);
          }
          return i;
        }

        isFood(x, y) {
          return this.data[x][y] === -3;
        }

        isWall(x, y) {
          if (x < 0 || y < 0 || x >= this.w || y >= this.h) return true;
          if (this.data[x][y] === -2) return true;
          if (this.data[x][y] >= 0) return true;
          return false;
        }

        render() {
          const ctx = this.ctx;
          const data = this.renderData;
          const color = this.colors;
          ctx.clearRect(0, 0, this.width, this.height);
          for (let x = 0; x < this.w; x++) {
            for (let y = 0; y < this.h; y++) {
              ctx.fillStyle = color[data[x][y]];
              ctx.fillRect(x * this.size, y * this.size, this.size, this.size);
            }
          }
        }

        reset() {
          this.data = [];
          for (let i = 0; i < this.width / this.size; i++) {
            const col = [];
            for (let j = 0; j < this.height / this.size; j++) col.push(-1);
            this.data.push(col);
          }

          this.newSnake();
          this.newFood();

          return this.observation;
        }

        get actions() {
          return ["l", "r", "u", "d"];
        }

        step(action) {
          const [x, y] = this.snake_start;
          let newX = x,
            newY = y;

          this.consume++;

          switch (action) {
            case "l":
              newX = x - 1;
              break;
            case "r":
              newX = x + 1;
              break;
            case "u":
              newY = y - 1;
              break;
            case "d":
              newY = y + 1;
              break;
          }

          let reward = -0.02,
            done = false;

          if (!this.isWall(newX, newY)) {
            this.snake_start = [newX, newY];
            this.data[x][y] = this.XY2Index(newX, newY);
            if (!this.isFood(newX, newY)) {
              const [x, y] = this.snake_end;
              this.snake_end = this.Index2XY(this.data[x][y]);
              this.data[x][y] = -1;
            } else {
              this.snake_len++;
              if (this.newFood()) reward = 1;
              else {
                reward = 10;
                done = true;
              }
              // reward -= this.consume * 0.001;
            }
            this.data[newX][newY] = this.XY2Index(newX, newY);
          } else {
            reward = -this.snake_len;
            done = true;
          }

          return [this.observation, reward, done];
        }
      }

      /**
       * 学习器
       */
      class QLearningTable {
        /**
         * @param {string[]} actions
         */
        constructor(
          actions,
          learning_rate = 0.01,
          reward_decay = 0.9,
          e_greedy = 0.9
        ) {
          this.actions = actions;
          this.learning_rate = learning_rate;
          this.reward_decay = reward_decay;
          this.e_greedy = e_greedy;

          this.data = {};

          this.stateLink = new Map();
        }
        /**
         * 加载配置文件
         */
        loadData(data) {
          this.data = data;
        }

        saveData(data) {
          return this.data;
        }

        //////////////////////////////
        newState() {
          return Object.fromEntries(this.actions.map((name) => [name, 0]));
        }

        getState(observation) {
          let state = this.data[observation];
          if (!state) {
            state = this.newState();
            this.data[observation] = state;
          }
          return state;
        }

        /**
         * 寻找某状态下的最佳决策
         * 从决策表中
         */
        getMax(state) {
          let max = ["", -Infinity];
          Object.entries(state).forEach(([action, value]) => {
            if (value > max[1]) max = [action, value];
          });
          return max;
        }

        /**
         * 在预定环境选择最佳决策
         */
        predict(observation) {
          const state = this.getState(observation);

          const list = Object.entries(state);

          if (Math.random() > this.e_greedy) {
            return list[(Math.random() * list.length) | 0][0];
          }

          return this.getMax(state)[0];
        }

        /**
         * 执行一步学习
         */
        learn(observation, action, reward, observation_) {
          //环境观察为一个hash字符串 此环境对应一个在此环境中做决策的数组
          //state[action]->value  or  table[observ][action]->value
          const state = this.getState(observation);
          let newValue;
          if (observation_ !== "over") {
            const state_ = this.getState(observation_);
            newValue = reward + this.reward_decay * this.getMax(state_)[1];
          } else {
            newValue = reward;
          }
          state[action] += this.learning_rate * (newValue - state[action]);
        }

        reset() {}
      }
    </script>
  </head>
  <body>
    <canvas id="canvas" width="300" height="300"></canvas>
    <br />
    <div>轮数</div>
    <a id="episode"></a>
    <br />
    <div>得分</div>
    <a id="score"></a>
    <br />
    <div>历史最高分</div>
    <a id="maxscore"></a>
    <br />
    <button onclick="saveJSON()">save</button>
    <br />
    <input type="file" id="file" /><button onclick="loadJSON()">load</button>
    <br />
    <button onclick="quick()">quick</button>
    <br />
    <button onclick="normal()">normal</button>
    <br />
    <button onclick="stopAll()">stop</button>
    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const env = new Env(ctx, 300, 300, 60);
      const RL = new QLearningTable(env.actions);
      const episodeEle = document.getElementById("episode");
      const scoreEle = document.getElementById("score");
      const maxscoreEle = document.getElementById("maxscore");
      const fileEle = document.getElementById("file");
      let maxscore = 0;

      let stop = false;

      function saveJSON() {
        download(
          JSON.stringify(RL.saveData()),
          "data.json",
          "application/json"
        );
      }

      function loadJSON() {
        const files = fileEle.files;
        if (files.length > 0) {
          const reader = new FileReader();
          reader.readAsText(files[0]);
          reader.onload = function () {
            RL.loadData(JSON.parse(this.result));
          };
        }
      }

      function stopAll() {
        stop = true;
      }

      async function quick() {
        stop = false;
        RL.e_greedy = 0.95;
        for (let episode = 1; ; episode++) {
          let score = 0;
          RL.reset();
          for (let observation = env.reset(); ; ) {
            const action = RL.predict(observation);
            const [observation_, reward, done] = env.step(action);
            RL.learn(observation, action, reward, observation_);
            observation = observation_;
            if (done) break;
          }
          score = env.snake_len;
          episodeEle.innerText = episode;
          scoreEle.innerText = score;
          if (score > maxscore) {
            maxscore = score;
            maxscoreEle.innerText = score;
          }
          if (!(episode % 1000)) await new Promise((r) => setTimeout(r));
          if (stop) break;
        }
      }

      async function normal() {
        stop = false;
        RL.e_greedy = 1;
        for (let episode = 1; ; episode++) {
          let score = 0;
          RL.reset();
          for (let observation = env.reset(); ; ) {
            env.render();
            await new Promise((r) => setTimeout(r, 200));
            const action = RL.predict(observation);
            const [observation_, reward, done] = env.step(action);
            RL.learn(observation, action, reward, observation_);
            observation = observation_;
            if (done) break;
          }
          score = env.snake_len;
          episodeEle.innerText = episode;
          scoreEle.innerText = score;
          if (score > maxscore) {
            maxscore = score;
            maxscoreEle.innerText = score;
          }
          if (stop) break;
        }
      }
    </script>
  </body>
</html>
